/*
切片
	1、切片是引用类型的数据，它指向的是底层数组的地址。所以切片本身不存储任何数据。
	2、向切片内部追加数据的时候，如果追加后的切片长度超过追加前的切片容量，那么追加后的切片的容量要成倍的增加。
	3、切片的容量发生变化时，它的地址也发生改变，也就是说它指向了另一个数组。

	例如：切片 s1 := []int{1, 2, 3}，它的容量是 3，当向它内部追加数据的时候，由于超出了原来的容量，所以它要重新开辟一块内存，创建一个新的数组，切片指向这个新的数组的地址
*/
package main

import (
	"fmt"
)

func main() {
	s1 := []int{1, 2, 3}
	fmt.Println(s1)                               // [1 2 3]
	fmt.Printf("长度：%d，容量：%d\n", len(s1), cap(s1)) // 长度：3，容量：3
	fmt.Printf("地址：%p\n", s1)                     // 地址：0xc00000a3e0

	fmt.Println("-------------------------")

	// 追加两个数，超出了原来的容量，所以容量翻倍由 3 变成 6，地址发生了改变
	s1 = append(s1, 4, 5)
	fmt.Println(s1)                               // [1 2 3 4 5]
	fmt.Printf("长度：%d，容量：%d\n", len(s1), cap(s1)) // 长度：5，容量：6
	fmt.Printf("地址：%p\n", s1)                     // 地址：0xc00000e240

	fmt.Println("-------------------------")

	// 追加三个数，超出了原来的容量，所以容量翻倍由 6 变成 12，地址发生了改变
	s1 = append(s1, 6, 7, 8)
	fmt.Println(s1)                               // [1 2 3 4 5 6 7 8]
	fmt.Printf("长度：%d，容量：%d\n", len(s1), cap(s1)) // 长度：8，容量：12
	fmt.Printf("地址：%p\n", s1)                     // 地址：0xc00003e060

	fmt.Println("-------------------------")

	// 追加两个数，原来的容量是 12，长度是 8，追加后长度变成 10，容量不变，所以地址也不变
	s1 = append(s1, 9, 10)
	fmt.Println(s1)                               // [1 2 3 4 5 6 7 8 9 10]
	fmt.Printf("长度：%d，容量：%d\n", len(s1), cap(s1)) // 长度：10，容量：12
	fmt.Printf("地址：%p\n", s1)                     // 地址：0xc00003e060

	fmt.Println("-------------------------")
}
